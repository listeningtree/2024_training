{"name": "test_01_baili[args0]", "status": "broken", "statusDetails": {"message": "TypeError: can't concat str to bytes", "trace": "self = <test_research.TestResearch object at 0x000002200A0DB9B0>\nargs = {'name': '输入100以内个字符（不包括100字符），可以正常输入', 'request': {'headers': {'Accept': 'text/html,application/xhtml+xml,application...com/s'}, 'test': '好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好'}\n\n    @pytest.mark.parametrize('args',YamlUtil(os.getcwd()+'\\\\test_api.yaml').read_yaml())\n    def test_01_baili(self,args):\n        # headers = {\n        #     'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36 Edg/83.0.478.50',\n        #     'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'\n        # }\n        # url = \"https://www.baidu.com/s?wd=areyouok\"\n        #\n        # req = urllib.request.Request(url=url, headers=headers)\n        # html = urllib.request.urlopen(req).read().decode('UTF-8', 'ignore')\n        # print(html)\n    \n        # url=args['request']['url']\n        # headers=args['request']['headers']\n        # print('这是什么鬼')\n        # print(args['request']['headers'])\n        # params=args['request']['params']\n        # #params=args.get('request').get('params')\n        # res=requests.get(url,headers=headers,params=params)\n        # print(args)\n        # print('让我看看咋回事')\n        #\n        # res.encoding = res.apparent_encoding\n        # print(res.text)\n        #\n        # # 断言\n        # #assert args.get('test') in res.text\n    \n        url = args['request']['url']\n        headers=args['request']['headers']\n        print('这是什么鬼')\n        print(args['request']['headers'])\n        params=args['request']['params']\n        #params=args.get('request').get('params')\n        req = urllib.request.Request(url,params)\n>       html = urllib.request.urlopen(req).read().decode('UTF-8', 'ignore')\n\ntest_research.py:45: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nC:\\Users\\13601\\AppData\\Local\\Programs\\Python\\Python37\\lib\\urllib\\request.py:222: in urlopen\n    return opener.open(url, data, timeout)\nC:\\Users\\13601\\AppData\\Local\\Programs\\Python\\Python37\\lib\\urllib\\request.py:525: in open\n    response = self._open(req, data)\nC:\\Users\\13601\\AppData\\Local\\Programs\\Python\\Python37\\lib\\urllib\\request.py:543: in _open\n    '_open', req)\nC:\\Users\\13601\\AppData\\Local\\Programs\\Python\\Python37\\lib\\urllib\\request.py:503: in _call_chain\n    result = func(*args)\nC:\\Users\\13601\\AppData\\Local\\Programs\\Python\\Python37\\lib\\urllib\\request.py:1360: in https_open\n    context=self._context, check_hostname=self._check_hostname)\nC:\\Users\\13601\\AppData\\Local\\Programs\\Python\\Python37\\lib\\urllib\\request.py:1317: in do_open\n    encode_chunked=req.has_header('Transfer-encoding'))\nC:\\Users\\13601\\AppData\\Local\\Programs\\Python\\Python37\\lib\\http\\client.py:1229: in request\n    self._send_request(method, url, body, headers, encode_chunked)\nC:\\Users\\13601\\AppData\\Local\\Programs\\Python\\Python37\\lib\\http\\client.py:1275: in _send_request\n    self.endheaders(body, encode_chunked=encode_chunked)\nC:\\Users\\13601\\AppData\\Local\\Programs\\Python\\Python37\\lib\\http\\client.py:1224: in endheaders\n    self._send_output(message_body, encode_chunked=encode_chunked)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <http.client.HTTPSConnection object at 0x0000022009EE8390>\nmessage_body = {'rsv_idx': 2, 'rsv_page': 1, 'usm': 3, 'wd': '好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好'}\nencode_chunked = True\n\n    def _send_output(self, message_body=None, encode_chunked=False):\n        \"\"\"Send the currently buffered request and clear the buffer.\n    \n        Appends an extra \\\\r\\\\n to the buffer.\n        A message_body may be specified, to be appended to the request.\n        \"\"\"\n        self._buffer.extend((b\"\", b\"\"))\n        msg = b\"\\r\\n\".join(self._buffer)\n        del self._buffer[:]\n        self.send(msg)\n    \n        if message_body is not None:\n    \n            # create a consistent interface to message_body\n            if hasattr(message_body, 'read'):\n                # Let file-like take precedence over byte-like.  This\n                # is needed to allow the current position of mmap'ed\n                # files to be taken into account.\n                chunks = self._read_readable(message_body)\n            else:\n                try:\n                    # this is solely to check to see if message_body\n                    # implements the buffer API.  it /would/ be easier\n                    # to capture if PyObject_CheckBuffer was exposed\n                    # to Python.\n                    memoryview(message_body)\n                except TypeError:\n                    try:\n                        chunks = iter(message_body)\n                    except TypeError:\n                        raise TypeError(\"message_body should be a bytes-like \"\n                                        \"object or an iterable, got %r\"\n                                        % type(message_body))\n                else:\n                    # the object implements the buffer interface and\n                    # can be passed directly into socket methods\n                    chunks = (message_body,)\n    \n            for chunk in chunks:\n                if not chunk:\n                    if self.debuglevel > 0:\n                        print('Zero length chunk ignored')\n                    continue\n    \n                if encode_chunked and self._http_vsn == 11:\n                    # chunked encoding\n                    chunk = f'{len(chunk):X}\\r\\n'.encode('ascii') + chunk \\\n>                       + b'\\r\\n'\nE                   TypeError: can't concat str to bytes\n\nC:\\Users\\13601\\AppData\\Local\\Programs\\Python\\Python37\\lib\\http\\client.py:1054: TypeError"}, "parameters": [{"name": "args", "value": "{'name': '输入100以内个字符（不包括100字符），可以正常输入', 'request': {'url': 'https://www.baidu.com/s', 'method': 'get', 'headers': {'Content-Type': 'application/json', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.97 Safari/537.36 Edg/83.0.478.50', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9'}, 'params': {'wd': '好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好', 'usm': 3, 'rsv_idx': 2, 'rsv_page': 1}}, 'test': '好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好好好好学习好好学习好'}"}], "start": 1719211818304, "stop": 1719211818455, "uuid": "5c523c22-fa49-46d8-86cb-84fe4500a8f2", "historyId": "cfb2c6955ced765720cc4d9af9db537d", "testCaseId": "7b939fd8aa016c0e835658ceff2d53b4", "fullName": "testcase.test_research.TestResearch#test_01_baili", "labels": [{"name": "parentSuite", "value": "testcase"}, {"name": "suite", "value": "test_research"}, {"name": "subSuite", "value": "TestResearch"}, {"name": "host", "value": "LAPTOP-UB0CHATK"}, {"name": "thread", "value": "14920-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "testcase.test_research"}]}